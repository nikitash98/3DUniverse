/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.0 public/3D/earth.glb 
*/

import {React, useRef} from 'react'
import { useGLTF, Sphere, useFBO } from '@react-three/drei'
import { Html } from '@react-three/drei';
import * as THREE from 'three';

import { useLoader, useFrame} from '@react-three/fiber';
export default function Earth_P(props) {
  const { nodes, materials } = useGLTF('3D/earth.glb')

  const earthDiffuse = useLoader(THREE.TextureLoader, 'Textures/Planets/Earth/EarthColorMap.png'); // Adjust the path to your texture
  const earthNormal = useLoader(THREE.TextureLoader, 'Textures/Planets/Earth/Earth_Normal.png'); // Adjust the path to your texture
  const earthClouds = useLoader(THREE.TextureLoader, 'Textures/Planets/Earth/EarthCloudMap.png'); // Adjust the path to your texture
  const earthRoughness = useLoader(THREE.TextureLoader, 'Textures/Planets/Earth/Earth_Specular.png'); // Adjust the path to your texture

  const materialRef = useRef();
  const cloudRef = useRef();

  const uniforms = {
    uTime: { value: 0.0 },
    atmOpacity: { value: 1.0 },
    atmPowFactor: { value: 4.1 },
    atmMultiplier: { value: 9.5 },

    
  };

  const earthuniforms = {
    dayMap: { value: new THREE.TextureLoader().load( 'Textures/Planets/Earth/EarthColorMap.png' ) },
    nightMap: { value: new THREE.TextureLoader().load( 'Textures/Planets/Earth/EarthNightColorMap.png' ) },
    lightDirection: {value: new THREE.Vector3(1, 0, 0)}
  }
  useFrame((state, delta) => {
    cloudRef.current.rotation.y += Math.PI/300 * delta;
  })
  const vertexShader = `
  varying vec2 vUv;
  varying vec3 vNormal;
  varying vec3 eyeVector;

  void main() {
    vec4 mvPos = modelViewMatrix * vec4( position, 1.0 );

    // normalMatrix is a matrix that is used to transform normals from object space to view space.
    vNormal = normalize( normalMatrix * normal );

    // vector pointing from camera to vertex in view space
    eyeVector = - (modelViewMatrix * vec4(position, 1.0)).xyz;

    vUv = uv;


    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;

const fragmentShader = `
  uniform float uTime;
  varying vec2 vUv;
  varying vec3 vNormal;
  varying vec3 eyeVector;


  uniform float atmOpacity;
  uniform float atmPowFactor;
  uniform float atmMultiplier;

  void main() {
    float dotP = dot( normalize(vNormal), normalize(eyeVector) );
    // This factor is to create the effect of a realistic thickening of the atmosphere coloring
    float factor = pow(dotP, atmPowFactor) * atmMultiplier;
    // Adding in a bit of dotP to the color to make it whiter while the color intensifies
    vec3 atmColor = vec3(0.5 + dotP/4.0, 0.8 + dotP/4.0, 1.0);
    // use atmOpacity to control the overall intensity of the atmospheric color
    gl_FragColor = vec4(pow(dotP, 2.0) * 3.0);
    gl_FragColor.rgb *= vec3(atmColor);
    gl_FragColor.a *= 0.2;
  }
`;


const earthVertexShader = `
  varying vec2 vUv;
  varying vec3 vNormal;
  varying vec3 wPos;

  void main() {
    vUv = uv;
    vNormal = normal;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }

`
const earthFragmentShader = `
  // Some code from here
  //https://matiasgf.dev/experiments/earth
  uniform sampler2D dayMap;
  uniform sampler2D nightMap;
  uniform vec3 lightDirection;
  varying vec3 vNormal;
  varying vec2 vUv;
  varying vec3 wPos;

  void main() {
    vec3 dayColor = texture2D(dayMap, vUv).rgb;
    vec3 nightColor = texture2D(nightMap, vUv).rgb;
    float lambertCoeff = dot(lightDirection, vNormal);

    vec3 viewDirection = normalize(cameraPosition - wPos);

    float fresnelBias = 0.0;
    float fresnelScale = 0.3;
    float fresnelFactor = fresnelBias + fresnelScale * pow(1.0 - dot(vNormal, normalize(viewDirection)), 3.0);
    vec3 atmosphereColor = vec3(0.51,0.714,1.);

    vec3 resultColor = vec3(1.0);
    resultColor = dayColor * max(lambertCoeff, 0.0);
    resultColor += atmosphereColor * fresnelFactor;
    resultColor += nightColor * max(-lambertCoeff, 0.0) * 0.2;
    gl_FragColor.rgb = resultColor;
    //gl_FragColor.rgb = dayColor * lambertCoeff + nightColor * (max(1.0-lambertCoeff, 0.0)) * (max(lambertCoeff, 0.2)) + atmosphereColor * fresnelFactor ;
  }

`
  return (
    <group {...props} dispose={null} scale={1.0}>
      {/*
      <mesh geometry={nodes.Clouds.geometry} material={materials['Material.001']} scale={1.034}  frustrumCulled={false} renderOrder={2}/>

      <mesh geometry={nodes.Atmosphere.geometry} scale={1.05} renderOrder={3}>
      <shaderMaterial
        ref={materialRef}
        uniforms={uniforms}
        vertexShader={vertexShader}
        fragmentShader={fragmentShader}
        side={THREE.BackSide}
        transparent
        
      />
      </mesh>
       */}

      <Sphere args={[1.0, 32, 32]} renderOrder={5}>
        <shaderMaterial
          ref={materialRef}
          uniforms={earthuniforms}
          vertexShader={earthVertexShader}
          fragmentShader={earthFragmentShader}
          />
      </Sphere>

      <Sphere args={[1.08, 64, 64]} renderOrder={1}>
        <shaderMaterial
          vertexShader={vertexShader}
          fragmentShader={fragmentShader}
          side={THREE.BackSide}
          transparent
        />

      </Sphere>
      {/*

      <Sphere args={[1, 64, 64]} renderOrder={1}>
        <meshStandardMaterial map = {earthDiffuse} normalMap={earthNormal}
        normalScale={0.5}
        roughness={0.7}
              normalMap-colorSpace={THREE.LinearSRGBColorSpace}
        />
      </Sphere>
       */}

      <Sphere args={[1.005, 32, 32]} ref={cloudRef} renderOrder={0}>
        <meshStandardMaterial map = {earthClouds} 
                  transparent 
                  opacity={1.0} 
                  blending={THREE.AdditiveBlending} 
                  depthWrite = {false}
        />
      </Sphere>


    </group>
  )
}

useGLTF.preload('/earth.glb')

