/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.0 public/3D/earth.glb 
*/

import {React, useRef} from 'react'
import { useGLTF, Sphere, useFBO } from '@react-three/drei'
import { Html } from '@react-three/drei';
import * as THREE from 'three';

import { useLoader, useFrame} from '@react-three/fiber';
export default function Earth_P(props) {
  const { nodes, materials } = useGLTF('3D/earth.glb')

  const earthDiffuse = useLoader(THREE.TextureLoader, 'Textures/Planets/Earth/Earth_Diffuse.png'); // Adjust the path to your texture
  const earthNormal = useLoader(THREE.TextureLoader, 'Textures/Planets/Earth/Earth_Normal.png'); // Adjust the path to your texture
  const earthClouds = useLoader(THREE.TextureLoader, 'Textures/Planets/Earth/Earth_Clouds.png'); // Adjust the path to your texture
  const earthRoughness = useLoader(THREE.TextureLoader, 'Textures/Planets/Earth/Earth_Specular.png'); // Adjust the path to your texture

  const materialRef = useRef();
  const cloudRef = useRef();

  const uniforms = {
    uTime: { value: 0.0 },
    atmOpacity: { value: 1.0 },
    atmPowFactor: { value: 4.1 },
    atmMultiplier: { value: 9.5 },
  };

  useFrame((state, delta) => {
    cloudRef.current.rotation.y += Math.PI/300 * delta;
  })
  const vertexShader = `
  varying vec2 vUv;
  varying vec3 vNormal;
  varying vec3 eyeVector;

  void main() {
    vec4 mvPos = modelViewMatrix * vec4( position, 1.0 );

    // normalMatrix is a matrix that is used to transform normals from object space to view space.
    vNormal = normalize( normalMatrix * normal );

    // vector pointing from camera to vertex in view space
    eyeVector = - (modelViewMatrix * vec4(position, 1.0)).xyz;

    vUv = uv;


    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;

const fragmentShader = `
  uniform float uTime;
  varying vec2 vUv;
  varying vec3 vNormal;
  varying vec3 eyeVector;


  uniform float atmOpacity;
  uniform float atmPowFactor;
  uniform float atmMultiplier;

  void main() {
    float dotP = dot( normalize(vNormal), normalize(eyeVector) );
    // This factor is to create the effect of a realistic thickening of the atmosphere coloring
    float factor = pow(dotP, atmPowFactor) * atmMultiplier;
    // Adding in a bit of dotP to the color to make it whiter while the color intensifies
    vec3 atmColor = vec3(0.5 + dotP/4.0, 0.8 + dotP/4.0, 1.0);
    // use atmOpacity to control the overall intensity of the atmospheric color
    gl_FragColor = vec4(pow(dotP, 2.0) * 3.0);
    gl_FragColor.rgb *= vec3(atmColor);
    gl_FragColor.a *= 0.2;
  }
`;


const earthFragmentShader = `
uniform sampler2D dayMap;
uniform sampler2D nightMap;
varying vec3 vNormal;
varying vec2 vUv;

`
  return (
    <group {...props} dispose={null} scale={1.0}>
      {/*
      <mesh geometry={nodes.Clouds.geometry} material={materials['Material.001']} scale={1.034}  frustrumCulled={false} renderOrder={2}/>

      <mesh geometry={nodes.Atmosphere.geometry} scale={1.05} renderOrder={3}>
      <shaderMaterial
        ref={materialRef}
        uniforms={uniforms}
        vertexShader={vertexShader}
        fragmentShader={fragmentShader}
        side={THREE.BackSide}
        transparent
        
      />
      </mesh>
       */}

      <Sphere args={[1.05, 32, 32]} renderOrder={3}>
        <shaderMaterial
          ref={materialRef}
          uniforms={uniforms}
          vertexShader={vertexShader}
          fragmentShader={fragmentShader}
          side={THREE.BackSide}
          transparent

          />
      </Sphere>

      <Sphere args={[1, 64, 64]} renderOrder={1}>
        <meshStandardMaterial map = {earthDiffuse} normalMap={earthNormal}
        normalScale={0.5}
        roughness={0.7}
              normalMap-colorSpace={THREE.LinearSRGBColorSpace}
        />
      </Sphere>

      <Sphere args={[1.01, 32, 32]} ref={cloudRef} renderOrder={0}>
        <meshStandardMaterial map = {earthClouds} 
                  transparent 
                  opacity={1.0} 
                  blending={THREE.AdditiveBlending} 
                  depthWrite = {false}
        />
      </Sphere>

      

    </group>
  )
}

useGLTF.preload('/earth.glb')

